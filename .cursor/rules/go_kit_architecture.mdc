---
description: 
globs: 
alwaysApply: true
---
- **Go-kit 架構分層原則**
  - 採用 Service → Endpoint → Transport → Middleware 分層
  - 每個 bounded context（如 block, transaction, account, network）皆保留原有 domain/model 設計
  - Service 層只處理業務邏輯，不直接依賴傳輸層
  - Endpoint 層負責將 Service 方法包裝為 endpoint.Endpoint
  - Transport 層負責 HTTP/gRPC 輸入輸出與解碼/編碼
  - Middleware 層可插入日誌、指標、驗證等橫切邏輯

- **目錄結構範例**
  ```
  internal/
    service/
      block/
        service.go
        middleware.go
    endpoint/
      block/
        endpoint.go
    transport/
      http/
        block.go
      grpc/
        block.go
    middleware/
      logging/
        logging.go
      metrics/
        metrics.go
  entity/
    domain/
      block/
        model/
        biz/
  ```

- **每層職責**
  - **Service**：定義 interface 與實作，聚焦業務邏輯，可組合 middleware
  - **Endpoint**：將 Service 方法轉為 endpoint.Endpoint，處理 request/response struct
  - **Transport**：負責協定（HTTP/gRPC）與路由、解碼、編碼
  - **Middleware**：可包裝 Service，實現日誌、指標、驗證等

- **實作要點**
  - Service interface 必須明確，便於測試與 mock
  - 依賴注入建議用 wire 管理
  - 測試時可針對 Service/Endpoint/Transport 各層獨立測試
  - 保留 entity/domain 下的 model/biz proto 與結構

- **DO**
  ```go
  // Service interface
  type Service interface {
    GetBlock(ctx context.Context, id string) (*model.Block, error)
  }

  // Endpoint 包裝
  func MakeGetBlockEndpoint(svc Service) endpoint.Endpoint { ... }

  // Transport 解碼/編碼
  func decodeGetBlockRequest(...) (interface{}, error) { ... }
  ```

- **DON'T**
  - 不要在 Transport 直接調用 repo 或資料庫
  - 不要將業務邏輯寫在 endpoint 或 transport
  - 不要破壞 domain/model 的封裝

- **參考**
  - 保留 entity/domain 下的 block, transaction, account, network 結構
  - 參考 Go-kit 官方文件與範例
